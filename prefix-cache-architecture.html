<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Prefix Cache Architecture — Block Lifecycle</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; background: #0d1117; color: #e6edf3; min-height: 100vh; padding: 24px; }
  h1 { text-align: center; font-size: 1.5rem; margin-bottom: 6px; color: #58a6ff; }
  .subtitle { text-align: center; color: #8b949e; margin-bottom: 20px; font-size: 0.85rem; }
  .container { max-width: 960px; margin: 0 auto; }
  .controls { display: flex; align-items: center; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; }
  .btn { padding: 8px 16px; border-radius: 6px; border: 1px solid #30363d; background: #21262d; color: #e6edf3; cursor: pointer; font-size: 0.85rem; font-weight: 600; transition: all 0.15s; user-select: none; display: inline-flex; align-items: center; gap: 5px; }
  .btn:hover { background: #30363d; }
  .btn.primary { background: #238636; border-color: #2ea043; }
  .btn.primary:hover { background: #2ea043; }
  .btn.play { background: #1f6feb; border-color: #388bfd; }
  .btn.play:hover { background: #388bfd; }
  .btn.stop { background: #9e1c23; border-color: #f85149; }
  .btn.stop:hover { background: #b62324; }
  .btn:disabled { opacity: 0.4; cursor: not-allowed; }
  .btn svg { width: 14px; height: 14px; fill: currentColor; }
  .step-label { color: #8b949e; font-size: 0.85rem; flex: 1; text-align: right; }
  .speed-control { display: flex; align-items: center; gap: 6px; color: #8b949e; font-size: 0.75rem; }
  .speed-control select { background: #161b22; color: #c9d1d9; border: 1px solid #30363d; border-radius: 4px; padding: 4px 6px; font-size: 0.75rem; cursor: pointer; }

  .narration { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 16px 20px; margin-bottom: 16px; min-height: 64px; }
  .narration .step-title { display: block; font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.04em; color: #58a6ff; margin-bottom: 6px; }
  .narration .step-body { display: block; font-size: 0.88rem; line-height: 1.6; color: #c9d1d9; }
  .narration .step-body .hl { color: #58a6ff; font-weight: 600; }
  .narration .step-body .yellow { color: #e3b341; font-weight: 600; }
  .narration .step-body .green { color: #3fb950; font-weight: 600; }
  .narration .step-body .red { color: #f85149; font-weight: 600; }

  .progress-bar { display: flex; gap: 3px; margin-bottom: 16px; }
  .progress-dot { flex: 1; height: 4px; border-radius: 2px; background: #21262d; transition: background 0.3s; }
  .progress-dot.done { background: #238636; }
  .progress-dot.current { background: #58a6ff; }

  .section-title { font-size: 0.75rem; font-weight: 700; color: #8b949e; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 8px; display: flex; align-items: center; gap: 6px; }
  .section-title .count { background: #30363d; padding: 1px 8px; border-radius: 10px; font-size: 0.7rem; }
  .block-grid { display: flex; flex-wrap: wrap; gap: 6px; min-height: 56px; padding: 12px; background: #161b22; border: 1px solid #30363d; border-radius: 8px; }
  .block { width: 68px; height: 52px; border-radius: 6px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 0.65rem; font-weight: 700; border: 2px solid transparent; transition: all 0.4s ease; position: relative; }
  .block .block-id { font-size: 0.75rem; font-weight: 800; }
  .block .block-info { font-size: 0.55rem; opacity: 0.8; margin-top: 1px; }
  .block .ref-badge { position: absolute; top: -4px; right: -4px; width: 16px; height: 16px; border-radius: 50%; font-size: 0.55rem; display: flex; align-items: center; justify-content: center; font-weight: 800; }
  .block.free-empty { background: #161b22; border-color: #30363d; color: #484f58; }
  .block.free-empty .ref-badge { background: #21262d; color: #484f58; }
  .block.free-cached { background: #2a1d00; border-color: #d29922; color: #e3b341; }
  .block.free-cached .ref-badge { background: #2a1d00; color: #d29922; border: 1px solid #d29922; }
  .block.allocated { background: #122d1e; border-color: #2ea043; color: #3fb950; }
  .block.allocated .ref-badge { background: #122d1e; color: #2ea043; border: 1px solid #2ea043; }

  .free-queue-box { margin-bottom: 16px; }
  .queue-visual { display: flex; align-items: center; gap: 2px; padding: 12px; background: #161b22; border: 1px solid #30363d; border-radius: 8px; overflow-x: auto; min-height: 48px; }
  .queue-label { font-size: 0.6rem; color: #484f58; padding: 4px 6px; flex-shrink: 0; }
  .queue-label.head { color: #f85149; }
  .queue-label.tail { color: #3fb950; }
  .queue-item { min-width: 36px; height: 32px; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; font-weight: 700; flex-shrink: 0; }
  .queue-item.cached { background: #2a1d00; border: 1px solid #d29922; color: #e3b341; }
  .queue-item.empty-q { background: #161b22; border: 1px solid #30363d; color: #484f58; }
  .queue-arrow { color: #30363d; font-size: 0.7rem; flex-shrink: 0; }

  .hash-table { margin-bottom: 16px; }
  .hash-entries { display: flex; flex-wrap: wrap; gap: 4px; padding: 12px; background: #161b22; border: 1px solid #30363d; border-radius: 8px; min-height: 40px; }
  .hash-entry { padding: 4px 10px; border-radius: 4px; font-size: 0.65rem; font-weight: 600; background: #2a1d00; border: 1px solid #d29922; color: #e3b341; }
  .empty-msg { color: #484f58; font-size: 0.75rem; font-style: italic; }

  .metrics-bar { display: flex; gap: 12px; flex-wrap: wrap; margin-bottom: 16px; }
  .metric { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 10px 16px; flex: 1; min-width: 120px; }
  .metric-label { font-size: 0.65rem; color: #8b949e; text-transform: uppercase; letter-spacing: 0.04em; }
  .metric-value { font-size: 1.2rem; font-weight: 800; margin-top: 2px; }
  .metric-value.green { color: #3fb950; }
  .metric-value.yellow { color: #e3b341; }
  .metric-value.blue { color: #58a6ff; }

  .legend { display: flex; gap: 14px; flex-wrap: wrap; }
  .legend-item { display: flex; align-items: center; gap: 5px; font-size: 0.72rem; color: #8b949e; }
  .legend-dot { width: 14px; height: 14px; border-radius: 3px; }

  .req-indicators { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
  .req-ind { padding: 4px 12px; border-radius: 6px; font-size: 0.75rem; font-weight: 600; border: 1px solid #30363d; background: #161b22; color: #484f58; transition: all 0.3s; }
  .req-ind.active { border-color: #2ea043; background: #122d1e; color: #3fb950; }
  .req-ind.finished { border-color: #30363d; background: #161b22; color: #8b949e; text-decoration: line-through; }
</style>
</head>
<body>

<div class="container">
  <h1>Prefix Cache Architecture</h1>
  <p class="subtitle">Block lifecycle, free queue, LRU eviction, and hash table — visualized step by step</p>

  <div class="controls">
    <button class="btn" id="prevBtn" onclick="go(-1)">
      <svg viewBox="0 0 16 16"><path d="M9.78 12.78a.75.75 0 01-1.06 0L4.47 8.53a.75.75 0 010-1.06l4.25-4.25a.75.75 0 011.06 1.06L6.06 8l3.72 3.72a.75.75 0 010 1.06z"/></svg>
      Prev
    </button>
    <button class="btn primary" id="nextBtn" onclick="go(1)">
      Next
      <svg viewBox="0 0 16 16"><path d="M6.22 3.22a.75.75 0 011.06 0l4.25 4.25a.75.75 0 010 1.06l-4.25 4.25a.75.75 0 01-1.06-1.06L9.94 8 6.22 4.28a.75.75 0 010-1.06z"/></svg>
    </button>
    <button class="btn play" id="playBtn" onclick="togglePlay()">
      <svg id="playIcon" viewBox="0 0 16 16"><path d="M4 2l10 6-10 6z"/></svg>
      <svg id="stopIcon" viewBox="0 0 16 16" style="display:none"><rect x="3" y="3" width="10" height="10" rx="1"/></svg>
      <span id="playLabelEl">Play</span>
    </button>
    <div class="speed-control">
      <label for="speedSel">Speed:</label>
      <select id="speedSel">
        <option value="3000">Slow</option>
        <option value="1800" selected>Normal</option>
        <option value="1000">Fast</option>
      </select>
    </div>
    <span class="step-label" id="stepLabel">Step 0 / 14</span>
  </div>

  <div class="progress-bar" id="progressBar"></div>

  <div class="narration" id="narration">
    <span class="step-title">Getting Started</span>
    <span class="step-body">Click <span class="hl">Next</span> to step through, or <span class="hl">Play</span> to auto-advance.</span>
  </div>

  <div class="req-indicators" id="reqIndicators"></div>

  <div class="metrics-bar">
    <div class="metric"><div class="metric-label">Total Blocks</div><div class="metric-value blue">8</div></div>
    <div class="metric"><div class="metric-label">Allocated</div><div class="metric-value green" id="mAllocated">0</div></div>
    <div class="metric"><div class="metric-label">Free + Cached</div><div class="metric-value yellow" id="mCached">0</div></div>
    <div class="metric"><div class="metric-label">Free + Empty</div><div class="metric-value blue" id="mEmpty">8</div></div>
    <div class="metric"><div class="metric-label">KV Usage</div><div class="metric-value green" id="mUsage">0%</div></div>
  </div>

  <div class="section-title">Block Pool <span class="count">8 blocks</span></div>
  <div class="block-grid" id="blockPool"></div>

  <div class="free-queue-box">
    <div class="section-title" style="margin-top:12px">Free Queue <span class="count">LRU ← HEAD ... TAIL → MRU</span></div>
    <div class="queue-visual" id="freeQueue"></div>
  </div>

  <div class="hash-table">
    <div class="section-title">Hash Table <span class="count" id="hashCount">0 entries</span></div>
    <div class="hash-entries" id="hashEntries"><span class="empty-msg">Empty — no blocks cached yet</span></div>
  </div>

  <div class="legend">
    <div class="legend-item"><div class="legend-dot" style="background:#161b22;border:2px solid #30363d"></div> Free + Empty</div>
    <div class="legend-item"><div class="legend-dot" style="background:#2a1d00;border:2px solid #d29922"></div> Free + Cached</div>
    <div class="legend-item"><div class="legend-dot" style="background:#122d1e;border:2px solid #2ea043"></div> Allocated</div>
  </div>
</div>

<script>
const TOTAL = 8;
const MAX = 14;
let currentStep = 0;
let playing = false;
let playTimer = null;

/* ── Pure state builder: replays from step 0 every time ── */
function buildState(targetStep) {
  // Fresh state
  var blk = [];
  for (var i = 0; i < TOTAL; i++) {
    blk.push({ id: i, state: 'free-empty', ref: 0, hash: null, owner: null });
  }
  var fq = [];
  for (var i = 0; i < TOTAL; i++) fq.push(i);
  var ht = {};
  var reqs = {};

  function allocFromQueue(rid, count) {
    var out = [];
    for (var j = 0; j < count; j++) {
      var bid = fq.shift();
      var b = blk[bid];
      if (b.hash) { delete ht[b.hash]; b.hash = null; }
      b.state = 'allocated';
      b.ref = 1;
      b.owner = rid;
      out.push(bid);
    }
    reqs[rid] = { blocks: out.slice(), status: 'active' };
    return out;
  }

  function setHashes(ids, hashes) {
    for (var j = 0; j < ids.length; j++) {
      blk[ids[j]].hash = hashes[j];
      ht[hashes[j]] = ids[j];
    }
  }

  function freeReq(rid) {
    reqs[rid].status = 'finished';
    var rev = reqs[rid].blocks.slice().reverse();
    for (var j = 0; j < rev.length; j++) {
      var b = blk[rev[j]];
      b.ref = 0;
      b.owner = null;
      b.state = b.hash ? 'free-cached' : 'free-empty';
      fq.push(rev[j]);
    }
  }

  function touchBlocks(ids, rid) {
    for (var j = 0; j < ids.length; j++) {
      var idx = fq.indexOf(ids[j]);
      if (idx >= 0) fq.splice(idx, 1);
      blk[ids[j]].ref += 1;
      blk[ids[j]].state = 'allocated';
      blk[ids[j]].owner = rid;
    }
    if (!reqs[rid]) {
      reqs[rid] = { blocks: ids.slice(), status: 'active' };
    } else {
      for (var j = 0; j < ids.length; j++) {
        if (reqs[rid].blocks.indexOf(ids[j]) === -1) reqs[rid].blocks.push(ids[j]);
      }
    }
  }

  // Step 1: Req1 arrives, allocate 4 blocks, hash first 3
  if (targetStep >= 1) {
    allocFromQueue('Req1', 4);
    setHashes([0, 1, 2], ['A1', 'A2', 'A3']);
  }
  // Step 2: narration only (same state as step 1)
  // Step 3: Req1 finishes — hash B3, then free
  if (targetStep >= 3) {
    setHashes([3], ['A4']);
    freeReq('Req1');
  }
  // Step 4: narration only
  // Step 5: Req2 — touch B0-B3, allocate 1 new
  if (targetStep >= 5) {
    touchBlocks([0, 1, 2, 3], 'Req2');
    var newBid = fq.shift();
    blk[newBid].state = 'allocated';
    blk[newBid].ref = 1;
    blk[newBid].owner = 'Req2';
    reqs['Req2'].blocks.push(newBid);
  }
  // Step 6: narration only
  // Step 7: Req2 finishes
  if (targetStep >= 7) {
    freeReq('Req2');
  }
  // Step 8: narration only
  // Step 9: Req3 — allocate 6 blocks (evicts cached)
  if (targetStep >= 9) {
    var a3 = allocFromQueue('Req3', 6);
    setHashes(a3.slice(0, 5), ['C1', 'C2', 'C3', 'C4', 'C5']);
  }
  // Step 10: narration only
  // Step 11: Req3 finishes
  if (targetStep >= 11) {
    freeReq('Req3');
  }
  // Step 12: narration only
  // Step 13: Req4 — allocate 4 blocks
  if (targetStep >= 13) {
    var a4 = allocFromQueue('Req4', 4);
    setHashes(a4.slice(0, 3), ['A1', 'A2', 'A3']);
  }
  // Step 14: narration only (same state as 13)

  return { blk: blk, fq: fq, ht: ht, reqs: reqs };
}

var narrations = [
  ['Getting Started',
   'Click <span class="hl">Next</span> to step through, or <span class="hl">Play</span> to auto-advance. We simulate a pool of <span class="hl">8 blocks</span> with block_size=4 tokens.'],
  ['Step 1 — Request 1 Arrives',
   'Request 1 has 16 tokens → needs 4 blocks. Blocks <span class="green">B0–B3</span> are allocated from the free queue. The first 3 full blocks are <span class="hl">hashed</span> and registered in the hash table. B3 is partial (not yet cacheable).'],
  ['Step 2 — Understanding the State',
   'B0–B3 are <span class="green">allocated</span> with ref_cnt=1 (owned by Req1). B4–B7 remain in the free queue as empty blocks. The hash table has 3 entries for the 3 full blocks.'],
  ['Step 3 — Request 1 Finishes',
   'All blocks are freed in <span class="hl">reverse order</span> (B3→B2→B1→B0) and go to the free queue tail. KV data and hashes <span class="yellow">stay intact</span> on GPU. Blocks become "free + cached." Unique/tail blocks are evicted first, prefix blocks last.'],
  ['Step 4 — Retention: No TTL',
   'All 4 cached blocks sit in the free queue with valid KV data on GPU. There is <span class="hl">no TTL</span> — they live here forever until evicted by memory pressure. KV cache usage = <span class="green">0%</span> (all blocks are free), yet the cache is full of reusable data.'],
  ['Step 5 — Request 2: Cache HIT',
   'Request 2 has the same prefix! The scheduler hashes its tokens → finds B0–B3 in the hash table → <span class="green">cache HIT</span>. These blocks are <span class="hl">touched</span>: removed from the free queue and ref_cnt incremented. Only 1 new block needed for the unique tokens.'],
  ['Step 6 — Touch Mechanism Explained',
   'Cached blocks B0–B3 transitioned from <span class="yellow">free+cached</span> → <span class="green">allocated</span>. By removing them from the free queue, they\'re protected from eviction while Req2 runs. This is why frequently-hit prefixes survive the longest.'],
  ['Step 7 — Request 2 Finishes',
   'Blocks freed in reverse order again. B4 (unique, no hash) enters the free queue first → evicted first. B3→B0 (cached prefix) enter last → evicted last. Prefix blocks always get the <span class="green">best survival priority</span>.'],
  ['Step 8 — Request 3: Different Prompt',
   'Request 3 arrives with a <span class="red">completely different</span> prompt — 24 tokens → needs 6 blocks. Some cached blocks will need to be evicted...'],
  ['Step 9 — LRU Eviction in Action',
   'Blocks are popped from the <span class="red">head</span> of the free queue (LRU order). Empty/unique blocks consumed first. Then cached prefix blocks are evicted: hashes <span class="red">cleared</span>, GPU memory slots overwritten. The old prefix cache is gone.'],
  ['Step 10 — Hash Table Updated',
   'Old hashes (<span class="red">#A1–#A4</span>) have been removed. New hashes (<span class="yellow">#C1–#C5</span>) from Req3\'s full blocks are added. The prefix cache now holds Req3\'s data instead of Req1\'s.'],
  ['Step 11 — Request 3 Finishes',
   'Req3\'s blocks are freed to the tail of the free queue (reverse order). Cached blocks retain their hashes — available for any future request with the same prefix as Req3.'],
  ['Step 12 — Request 4: Original Prompt Returns',
   'Request 4 arrives with the <span class="hl">same prompt as Request 1</span>. The scheduler checks the hash table... but the old entries were evicted by Req3. <span class="red">Cache MISS</span> — must recompute from scratch.'],
  ['Step 13 — Req4 Rebuilds the Cache',
   'Req4 allocates 4 blocks — some of Req3\'s cached blocks are evicted. Req4\'s full blocks are hashed and cached, <span class="green">rebuilding</span> the prefix cache for this prompt pattern.'],
  ['Step 14 — Key Takeaways',
   '① <span class="hl">No TTL</span> — blocks live until evicted by memory pressure.<br>② <span class="red">LRU eviction</span> from the free queue head (oldest first).<br>③ Prefix blocks freed to the tail → <span class="green">survive longest</span>.<br>④ <span class="yellow">Free+cached</span> blocks show as 0% KV usage but still hold valid data.<br>⑤ Hash table size (actual cache contents) is <span class="hl">not exposed</span> as a Prometheus metric.']
];

/* ── Render everything from computed state ── */
function render() {
  var s = buildState(currentStep);

  // Block pool
  var pool = document.getElementById('blockPool');
  pool.innerHTML = '';
  for (var i = 0; i < s.blk.length; i++) {
    var b = s.blk[i];
    var div = document.createElement('div');
    div.className = 'block ' + b.state;
    var info = '';
    if (b.state === 'free-cached') info = '#' + b.hash;
    else if (b.state === 'allocated') info = b.owner || '';
    else info = 'empty';
    div.innerHTML = '<span class="block-id">B' + b.id + '</span>'
      + '<span class="block-info">' + info + '</span>'
      + '<span class="ref-badge">' + b.ref + '</span>';
    pool.appendChild(div);
  }

  // Free queue
  var qEl = document.getElementById('freeQueue');
  qEl.innerHTML = '';
  if (s.fq.length === 0) {
    qEl.innerHTML = '<span class="empty-msg">Empty — all blocks allocated</span>';
  } else {
    var head = document.createElement('span');
    head.className = 'queue-label head';
    head.textContent = 'EVICT FIRST →';
    qEl.appendChild(head);
    for (var i = 0; i < s.fq.length; i++) {
      if (i > 0) {
        var arrow = document.createElement('span');
        arrow.className = 'queue-arrow';
        arrow.textContent = '⇄';
        qEl.appendChild(arrow);
      }
      var item = document.createElement('div');
      var b = s.blk[s.fq[i]];
      item.className = 'queue-item ' + (b.hash ? 'cached' : 'empty-q');
      item.textContent = 'B' + b.id;
      qEl.appendChild(item);
    }
    var tail = document.createElement('span');
    tail.className = 'queue-label tail';
    tail.textContent = '← KEEP LONGEST';
    qEl.appendChild(tail);
  }

  // Hash table
  var hEl = document.getElementById('hashEntries');
  var hKeys = Object.keys(s.ht);
  document.getElementById('hashCount').textContent = hKeys.length + ' entries';
  hEl.innerHTML = '';
  if (hKeys.length === 0) {
    hEl.innerHTML = '<span class="empty-msg">Empty — no blocks cached yet</span>';
  } else {
    for (var i = 0; i < hKeys.length; i++) {
      var entry = document.createElement('div');
      entry.className = 'hash-entry';
      entry.textContent = '#' + hKeys[i] + ' → B' + s.ht[hKeys[i]];
      hEl.appendChild(entry);
    }
  }

  // Metrics
  var allocated = 0, cached = 0, empty = 0;
  for (var i = 0; i < s.blk.length; i++) {
    if (s.blk[i].state === 'allocated') allocated++;
    else if (s.blk[i].state === 'free-cached') cached++;
    else empty++;
  }
  document.getElementById('mAllocated').textContent = allocated;
  document.getElementById('mCached').textContent = cached;
  document.getElementById('mEmpty').textContent = empty;
  document.getElementById('mUsage').textContent = Math.round(allocated / TOTAL * 100) + '%';

  // Request indicators
  var rEl = document.getElementById('reqIndicators');
  rEl.innerHTML = '';
  var rKeys = Object.keys(s.reqs);
  for (var i = 0; i < rKeys.length; i++) {
    var rid = rKeys[i];
    var r = s.reqs[rid];
    var div = document.createElement('div');
    div.className = 'req-ind ' + r.status;
    div.textContent = rid + ': blocks [' + r.blocks.join(',') + ']';
    rEl.appendChild(div);
  }

  // Narration
  var n = narrations[currentStep];
  document.getElementById('narration').innerHTML =
    '<span class="step-title">' + n[0] + '</span>'
    + '<span class="step-body">' + n[1] + '</span>';

  // Progress bar
  var pEl = document.getElementById('progressBar');
  pEl.innerHTML = '';
  for (var i = 0; i <= MAX; i++) {
    var dot = document.createElement('div');
    dot.className = 'progress-dot';
    if (i < currentStep) dot.className += ' done';
    else if (i === currentStep) dot.className += ' current';
    pEl.appendChild(dot);
  }

  // Button states
  document.getElementById('stepLabel').textContent = 'Step ' + currentStep + ' / ' + MAX;
  document.getElementById('prevBtn').disabled = (currentStep <= 0);
  document.getElementById('nextBtn').disabled = (currentStep >= MAX);
}

/* ── Navigation ── */
function go(dir) {
  var next = currentStep + dir;
  if (next < 0) next = 0;
  if (next > MAX) next = MAX;
  currentStep = next;
  render();
}

/* ── Play / Stop ── */
function togglePlay() {
  playing = !playing;
  updatePlayBtn();
  if (playing) {
    playTick();
  } else {
    clearTimeout(playTimer);
  }
}

function playTick() {
  if (!playing) return;
  if (currentStep >= MAX) {
    playing = false;
    updatePlayBtn();
    return;
  }
  currentStep++;
  render();
  var speed = parseInt(document.getElementById('speedSel').value, 10);
  playTimer = setTimeout(playTick, speed);
}

function updatePlayBtn() {
  document.getElementById('playIcon').style.display = playing ? 'none' : '';
  document.getElementById('stopIcon').style.display = playing ? '' : 'none';
  document.getElementById('playLabelEl').textContent = playing ? 'Stop' : 'Play';
  var btn = document.getElementById('playBtn');
  if (playing) {
    btn.classList.remove('play');
    btn.classList.add('stop');
  } else {
    btn.classList.remove('stop');
    btn.classList.add('play');
  }
}

/* ── Init ── */
render();
</script>
</body>
</html>