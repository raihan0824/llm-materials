<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PagedAttention vs Traditional Memory Management</title>
<style>
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    margin: 0;
    padding: 20px;
    background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
    min-height: 100vh;
    color: #e5e5e5;
}

.memory-wasted {
    background: linear-gradient(45deg, #666, #888);
    color: #ccc;
    opacity: 0.7;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 20px;
    padding: 30px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

h1 {
    text-align: center;
    margin-bottom: 30px;
    font-size: 2.5em;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}

.comparison-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 30px;
    margin: 40px 0;
}

.memory-section {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 15px;
    padding: 25px;
    border: 1px solid rgba(255, 255, 255, 0.05);
}

.section-title {
    font-size: 1.6em;
    margin-bottom: 20px;
    text-align: center;
    font-weight: bold;
}

.traditional-title { color: #ff6b6b; }
.paged-title { color: #4ecdc4; }

.memory-visualization {
    background: rgba(0, 0, 0, 0.6);
    border-radius: 10px;
    padding: 20px;
    margin: 20px 0;
    position: relative;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.1);
    min-height: 400px;
}

.memory-grid {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 4px;
    margin: 15px 0;
}

.memory-block {
    height: 30px;
    border-radius: 4px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7em;
    font-weight: bold;
    transition: all 0.3s ease;
    position: relative;
}

.memory-free {
    background: rgba(100, 100, 100, 0.3);
    color: #ccc;
}

.memory-used-r1 {
    background: linear-gradient(45deg, #ff6b6b, #ff8e53);
    color: white;
}

.memory-used-r2 {
    background: linear-gradient(45deg, #4ecdc4, #44a08d);
    color: white;
}

.memory-used-r3 {
    background: linear-gradient(45deg, #45b7d1, #96c93d);
    color: white;
}

.memory-page-r1 {
    background: linear-gradient(45deg, #ff6b6b, #ff8e53);
    color: white;
}

.memory-page-r2 {
    background: linear-gradient(45deg, #4ecdc4, #44a08d);
    color: white;
}

.memory-page-r3 {
    background: linear-gradient(45deg, #45b7d1, #96c93d);
    color: white;
}

.sequence-container {
    margin: 20px 0;
    padding: 15px;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.sequence-title {
    font-size: 1.1em;
    font-weight: bold;
    margin-bottom: 10px;
    color: #4ecdc4;
}

.token-sequence {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin: 10px 0;
}

.token {
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.8em;
    font-weight: bold;
    border: 1px solid rgba(255, 255, 255, 0.2);
    transition: all 0.3s ease;
}

.token-req1 { background: linear-gradient(45deg, #ff6b6b, #ff8e53); color: white; }
.token-req2 { background: linear-gradient(45deg, #4ecdc4, #44a08d); color: white; }
.token-req3 { background: linear-gradient(45deg, #45b7d1, #96c93d); color: white; }

.token-generating {
    animation: pulse 1.5s infinite;
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
}

@keyframes pulse {
    0%, 100% { opacity: 0.8; transform: scale(1); }
    50% { opacity: 1; transform: scale(1.1); }
}

.controls {
    text-align: center;
    margin: 30px 0;
}

.control-btn {
    background: linear-gradient(45deg, #2c3e50, #34495e);
    color: #e5e5e5;
    border: none;
    padding: 12px 24px;
    margin: 0 10px;
    border-radius: 25px;
    cursor: pointer;
    font-size: 1em;
    font-weight: bold;
    transition: all 0.3s ease;
    border: 2px solid rgba(255, 255, 255, 0.1);
}

.control-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.5);
    background: linear-gradient(45deg, #34495e, #2c3e50);
}

.control-btn:active {
    transform: translateY(0);
}

.stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    margin-top: 30px;
}

.stat-card {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 15px;
    padding: 20px;
    text-align: center;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.stat-title {
    font-size: 1.1em;
    margin-bottom: 10px;
    font-weight: bold;
}

.stat-value {
    font-size: 1.8em;
    font-weight: bold;
    margin: 10px 0;
}

.traditional-stat { color: #ff6b6b; }
.paged-stat { color: #4ecdc4; }
.improvement-stat { color: #96c93d; }

.explanation {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 10px;
    padding: 20px;
    margin: 20px 0;
    border-left: 4px solid #4ecdc4;
    border: 1px solid rgba(255, 255, 255, 0.05);
}

.explanation h3 {
    margin-top: 0;
    color: #4ecdc4;
}

.legend {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin: 20px 0;
    flex-wrap: wrap;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9em;
}

.legend-color {
    width: 20px;
    height: 20px;
    border-radius: 4px;
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.step-indicator {
    text-align: center;
    margin: 15px 0;
    font-size: 1.1em;
    font-weight: bold;
    color: #4ecdc4;
}

@media (max-width: 768px) {
    .comparison-container {
        grid-template-columns: 1fr;
        gap: 20px;
    }
    
    .stats {
        grid-template-columns: 1fr;
    }
    
    .memory-grid {
        grid-template-columns: repeat(6, 1fr);
    }
}
</style>
</head>
<body>
<div class="container">
<h1>üß† PagedAttention vs Traditional Memory</h1>

<div class="legend">
    <div class="legend-item">
        <div class="legend-color memory-free"></div>
        <span>Free Memory</span>
    </div>
    <div class="legend-item">
        <div class="legend-color memory-used-r1"></div>
        <span>Request 1 (Traditional)</span>
    </div>
    <div class="legend-item">
        <div class="legend-color memory-page-r1"></div>
        <span>Request 1 (PagedAttention)</span>
    </div>
    <div class="legend-item">
        <div class="legend-color memory-wasted"></div>
        <span>Wasted Memory</span>
    </div>
</div>

<div class="step-indicator" id="step-indicator">Step 1: Initial State - All memory free</div>

<div class="comparison-container">
    <div class="memory-section">
        <div class="section-title traditional-title">‚ùå Traditional Memory Management</div>
        <div class="memory-visualization">
            <div class="memory-grid" id="traditional-memory"></div>
            <div class="sequence-container">
                <div class="sequence-title">Request Sequences:</div>
                <div id="traditional-sequences"></div>
            </div>
        </div>
    </div>
    
    <div class="memory-section">
        <div class="section-title paged-title">‚úÖ PagedAttention Memory</div>
        <div class="memory-visualization">
            <div class="memory-grid" id="paged-memory"></div>
            <div class="sequence-container">
                <div class="sequence-title">Request Sequences:</div>
                <div id="paged-sequences"></div>
            </div>
        </div>
    </div>
</div>

<div class="controls">
    <button class="control-btn" onclick="playAnimation()">‚ñ∂Ô∏è Play Animation</button>
    <button class="control-btn" onclick="nextStep()">‚è≠Ô∏è Next Step</button>
    <button class="control-btn" onclick="resetAnimation()">üîÑ Reset</button>
</div>

<div class="stats">
    <div class="stat-card">
        <div class="stat-title traditional-stat">Traditional Efficiency</div>
        <div class="stat-value traditional-stat" id="traditional-efficiency">45%</div>
        <div>Memory Utilization</div>
    </div>
    <div class="stat-card">
        <div class="stat-title paged-stat">PagedAttention Efficiency</div>
        <div class="stat-value paged-stat" id="paged-efficiency">92%</div>
        <div>Memory Utilization</div>
    </div>
    <div class="stat-card">
        <div class="stat-title improvement-stat">Improvement</div>
        <div class="stat-value improvement-stat" id="improvement">2.0x</div>
        <div>Memory Efficiency</div>
    </div>
</div>

<div class="explanation">
    <h3>üè∑Ô∏è Block Label Explanation</h3>
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0;">
        <div><strong>Numbers (0-63):</strong> Original memory block addresses</div>
        <div><strong>R1, R2, R3:</strong> Request 1, 2, 3 data storage</div>
        <div><strong>W:</strong> Wasted/Reserved but unused memory</div>
        <div><strong>Free blocks:</strong> Available memory (gray)</div>
    </div>
    
    <h3>üîë Token-to-Memory Mapping</h3>
    <div style="background: rgba(0, 0, 0, 0.4); border-radius: 10px; padding: 20px; margin: 20px 0; border: 1px solid rgba(255, 255, 255, 0.1);">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px;">
            <div>
                <h4 style="color: #ff6b6b; margin-bottom: 15px;">üî¥ Traditional: 1 Token = 1 Block</h4>
                <div class="token-sequence" style="margin-bottom: 10px;">
                    <span class="token token-req1">The</span>
                    <span class="token token-req1">quick</span>
                    <span class="token token-req1">brown</span>
                    <span class="token token-req1">fox</span>
                    <span class="token token-req1">jumps</span>
                </div>
                <div style="font-size: 1.2em; margin: 10px 0;">‚¨áÔ∏è</div>
                <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; margin-bottom: 15px;">
                    <div class="memory-block memory-used-r1" style="height: 25px; font-size: 0.7em;">R1</div>
                    <div class="memory-block memory-used-r1" style="height: 25px; font-size: 0.7em;">R1</div>
                    <div class="memory-block memory-used-r1" style="height: 25px; font-size: 0.7em;">R1</div>
                    <div class="memory-block memory-used-r1" style="height: 25px; font-size: 0.7em;">R1</div>
                    <div class="memory-block memory-used-r1" style="height: 25px; font-size: 0.7em;">R1</div>
                </div>
                <div style="color: #ff6b6b; font-weight: bold;">5 tokens = 5 blocks</div>
                <div style="color: #ff6b6b; font-size: 0.9em;">+ 15 wasted blocks (pre-allocated)</div>
                <div style="color: #ff6b6b; font-weight: bold; font-size: 1.1em;">= 20 total blocks</div>
            </div>
            
            <div>
                <h4 style="color: #4ecdc4; margin-bottom: 15px;">üü¢ PagedAttention: 4 Tokens = 1 Page</h4>
                <div class="token-sequence" style="margin-bottom: 10px;">
                    <span class="token token-req1">The</span>
                    <span class="token token-req1">quick</span>
                    <span class="token token-req1">brown</span>
                    <span class="token token-req1">fox</span>
                    <span class="token token-req1">jumps</span>
                </div>
                <div style="font-size: 1.2em; margin: 10px 0;">‚¨áÔ∏è</div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; margin-bottom: 15px;">
                    <div class="memory-block memory-page-r1" style="height: 25px; font-size: 0.7em; display: flex; flex-direction: column; justify-content: center; line-height: 1.1;">
                        <div>Page 1</div>
                        <small style="font-size: 0.6em;">4 tokens</small>
                    </div>
                    <div class="memory-block memory-page-r1" style="height: 25px; font-size: 0.7em; display: flex; flex-direction: column; justify-content: center; line-height: 1.1;">
                        <div>Page 2</div>
                        <small style="font-size: 0.6em;">1 token</small>
                    </div>
                </div>
                <div style="color: #4ecdc4; font-weight: bold;">5 tokens = 2 pages</div>
                <div style="color: #4ecdc4; font-size: 0.9em;">+ 0 wasted pages</div>
                <div style="color: #4ecdc4; font-weight: bold; font-size: 1.1em;">= 2 total pages</div>
            </div>
        </div>
        
        <div style="text-align: center; margin-top: 20px; padding: 15px; background: rgba(96, 201, 60, 0.2); border-radius: 8px; border: 1px solid rgba(96, 201, 60, 0.3);">
            <strong style="color: #60c93c; font-size: 1.2em;">üí° Efficiency Gain: 20 blocks ‚Üí 2 pages = 10x less memory!</strong>
        </div>
    </div>
    
    <h3>üîë How PagedAttention Works</h3>
    <p><strong>Traditional Approach:</strong> Pre-allocates large contiguous memory blocks (20 blocks per request) for maximum sequence length, leading to significant waste when sequences are shorter than expected.</p>
    <p><strong>PagedAttention:</strong> Uses virtual memory concepts with fixed-size pages (typically 4 tokens per page). Memory is allocated dynamically as sequences grow, eliminating internal fragmentation.</p>
    <p><strong>Key Benefits:</strong></p>
    <ul>
        <li>üìà <strong>2-3x higher memory efficiency</strong> by eliminating wasted allocation</li>
        <li>üîÑ <strong>Dynamic allocation</strong> allows sequences to grow and shrink naturally</li>
        <li>üß© <strong>Non-contiguous storage</strong> reduces memory fragmentation</li>
        <li>‚ö° <strong>Better batching</strong> enables higher throughput with same hardware</li>
    </ul>
</div>

<div style="text-align: center; margin-top: 30px; padding: 15px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; font-size: 0.9em; color: rgba(255, 255, 255, 0.7); border: 1px solid rgba(255, 255, 255, 0.05);">
    Created by <strong style="color: #4ecdc4;">raihanafiandi</strong> ‚Ä¢ Inspired by vLLM PagedAttention
</div>
</div>

<script>
let currentStep = 0;
let animationRunning = false;
let autoPlay = false;

const steps = [
    "Step 1: Initial State - All memory free",
    "Step 2: First requests arrive - Allocating memory",
    "Step 3: Sequences generating tokens - Growing dynamically",
    "Step 4: Some sequences complete - Memory freed",
    "Step 5: New requests arrive - Efficient reallocation",
    "Step 6: Final state - Optimal memory usage"
];

const sequences = [
    { id: 'req1', tokens: ['The', 'quick', 'brown', 'fox', 'jumps', 'over', 'the', 'lazy', 'dog'], class: 'token-req1' },
    { id: 'req2', tokens: ['Hello', 'world', 'this', 'is', 'a', 'test'], class: 'token-req2' },
    { id: 'req3', tokens: ['AI', 'is', 'transforming', 'everything'], class: 'token-req3' }
];

function initializeMemory() {
    const traditionalGrid = document.getElementById('traditional-memory');
    const pagedGrid = document.getElementById('paged-memory');
    
    // Clear existing content
    traditionalGrid.innerHTML = '';
    pagedGrid.innerHTML = '';
    
    // Create 64 memory blocks for each grid
    for (let i = 0; i < 64; i++) {
        const traditionalBlock = document.createElement('div');
        traditionalBlock.className = 'memory-block memory-free';
        traditionalBlock.textContent = i.toString();
        traditionalBlock.id = `trad-${i}`;
        traditionalGrid.appendChild(traditionalBlock);
        
        const pagedBlock = document.createElement('div');
        pagedBlock.className = 'memory-block memory-free';
        pagedBlock.textContent = i.toString();
        pagedBlock.id = `page-${i}`;
        pagedGrid.appendChild(pagedBlock);
    }
}

function updateSequenceDisplay(containerId, sequencesToShow, step) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = '';
    
    sequencesToShow.forEach((seq, seqIndex) => {
        const seqDiv = document.createElement('div');
        seqDiv.innerHTML = `<strong>${seq.id.toUpperCase()}:</strong>`;
        const tokenDiv = document.createElement('div');
        tokenDiv.className = 'token-sequence';
        
        // Show more tokens as steps progress
        const tokensToShow = Math.min(seq.tokens.length, Math.max(1, step * 2 + seqIndex + 1));
        
        for (let i = 0; i < tokensToShow; i++) {
            const token = document.createElement('span');
            token.className = `token ${seq.class}`;
            token.textContent = seq.tokens[i];
            
            // Add generating animation to the last token if sequence isn't complete
            if (i === tokensToShow - 1 && tokensToShow < seq.tokens.length) {
                token.classList.add('token-generating');
            }
            
            tokenDiv.appendChild(token);
        }
        
        // Add ellipsis if there are more tokens
        if (tokensToShow < seq.tokens.length) {
            const ellipsis = document.createElement('span');
            ellipsis.className = 'token';
            ellipsis.textContent = '...';
            ellipsis.style.background = 'rgba(255,255,255,0.2)';
            ellipsis.style.color = '#ccc';
            tokenDiv.appendChild(ellipsis);
        }
        
        seqDiv.appendChild(tokenDiv);
        container.appendChild(seqDiv);
    });
}

function animateStep(step) {
    console.log('Animating step:', step); // Debug log
    document.getElementById('step-indicator').textContent = steps[step] || steps[steps.length - 1];
    
    // Reset all blocks to free with original numbers
    for (let i = 0; i < 64; i++) {
        const tradBlock = document.getElementById(`trad-${i}`);
        const pageBlock = document.getElementById(`page-${i}`);
        
        if (tradBlock) {
            tradBlock.className = 'memory-block memory-free';
            tradBlock.textContent = i.toString();
        }
        if (pageBlock) {
            pageBlock.className = 'memory-block memory-free';
            pageBlock.textContent = i.toString();
        }
    }
    
    switch(step) {
        case 0:
            // Initial state - all free
            updateSequenceDisplay('traditional-sequences', [], step);
            updateSequenceDisplay('paged-sequences', [], step);
            updateStats(0, 0);
            break;
            
        case 1:
            // Traditional: Allocate large blocks for Request 1
            // Allocates 20 blocks but only uses ~9 tokens
            for (let i = 0; i < 9; i++) {
                document.getElementById(`trad-${i}`).className = 'memory-block memory-used-r1';
                document.getElementById(`trad-${i}`).textContent = 'R1'; // R1 = Request 1 data
            }
            for (let i = 9; i < 20; i++) {
                document.getElementById(`trad-${i}`).className = 'memory-block memory-wasted';
                document.getElementById(`trad-${i}`).textContent = 'W'; // W = Wasted/Reserved but unused
            }
            
            // PagedAttention: Allocate only needed pages (3 pages of 4 tokens each)
            for (let i = 0; i < 3; i++) {
                document.getElementById(`page-${i}`).className = 'memory-block memory-page-r1';
                document.getElementById(`page-${i}`).textContent = 'R1'; // R1 = Request 1 pages
            }
            
            updateSequenceDisplay('traditional-sequences', [sequences[0]], step);
            updateSequenceDisplay('paged-sequences', [sequences[0]], step);
            updateStats(45, 75);
            break;
            
        case 2:
            // Traditional: Add Request 2, more waste
            // Request 1: blocks 0-19
            for (let i = 0; i < 9; i++) {
                document.getElementById(`trad-${i}`).className = 'memory-block memory-used-r1';
                document.getElementById(`trad-${i}`).textContent = 'R1';
            }
            for (let i = 9; i < 20; i++) {
                document.getElementById(`trad-${i}`).className = 'memory-block memory-wasted';
                document.getElementById(`trad-${i}`).textContent = 'W';
            }
            
            // Request 2: blocks 20-39 (6 tokens need 6 blocks, waste 14)
            for (let i = 20; i < 26; i++) {
                document.getElementById(`trad-${i}`).className = 'memory-block memory-used-r2';
                document.getElementById(`trad-${i}`).textContent = 'R2'; // R2 = Request 2 data
            }
            for (let i = 26; i < 40; i++) {
                document.getElementById(`trad-${i}`).className = 'memory-block memory-wasted';
                document.getElementById(`trad-${i}`).textContent = 'W';
            }
            
            // PagedAttention: Efficient allocation
            for (let i = 0; i < 3; i++) {
                document.getElementById(`page-${i}`).className = 'memory-block memory-page-r1';
                document.getElementById(`page-${i}`).textContent = 'R1';
            }
            for (let i = 3; i < 5; i++) {
                document.getElementById(`page-${i}`).className = 'memory-block memory-page-r2';
                document.getElementById(`page-${i}`).textContent = 'R2'; // R2 = Request 2 pages
            }
            
            updateSequenceDisplay('traditional-sequences', sequences.slice(0, 2), step);
            updateSequenceDisplay('paged-sequences', sequences.slice(0, 2), step);
            updateStats(38, 83);
            break;
            
        case 3:
            // Traditional: Add Request 3, maximum waste
            // All three requests with large allocations
            let tradIndex = 0;
            sequences.forEach((seq, seqIndex) => {
                const allocSize = 20; // Always allocate 20 blocks per request
                const actualUsed = seq.tokens.length; // Actual tokens needed
                
                for (let i = 0; i < allocSize && tradIndex + i < 64; i++) {
                    const blockId = `trad-${tradIndex + i}`;
                    const block = document.getElementById(blockId);
                    if (block) {
                        if (i < actualUsed) {
                            block.className = `memory-block memory-used-r${seqIndex + 1}`;
                            block.textContent = `R${seqIndex + 1}`;
                        } else {
                            block.className = 'memory-block memory-wasted';
                            block.textContent = 'W';
                        }
                    }
                }
                tradIndex += allocSize;
            });
            
            // PagedAttention: Exact allocation
            let pageIndex = 0;
            sequences.forEach((seq, seqIndex) => {
                const pages = Math.ceil(seq.tokens.length / 4); // 4 tokens per page
                for (let i = 0; i < pages && pageIndex < 64; i++) {
                    document.getElementById(`page-${pageIndex}`).className = `memory-block memory-page-r${seqIndex + 1}`;
                    document.getElementById(`page-${pageIndex}`).textContent = `R${seqIndex + 1}`;
                    pageIndex++;
                }
            });
            
            updateSequenceDisplay('traditional-sequences', sequences, step);
            updateSequenceDisplay('paged-sequences', sequences, step);
            updateStats(32, 87);
            break;
            
        case 4:
            // Traditional: Request 1 completes, but memory block remains allocated (wasted)
            for (let i = 0; i < 20; i++) {
                document.getElementById(`trad-${i}`).className = 'memory-block memory-wasted';
                document.getElementById(`trad-${i}`).textContent = 'W'; // Still allocated but request is done
            }
            // Request 2 continues
            for (let i = 20; i < 26; i++) {
                document.getElementById(`trad-${i}`).className = 'memory-block memory-used-r2';
                document.getElementById(`trad-${i}`).textContent = 'R2';
            }
            for (let i = 26; i < 40; i++) {
                document.getElementById(`trad-${i}`).className = 'memory-block memory-wasted';
                document.getElementById(`trad-${i}`).textContent = 'W';
            }
            // Request 3 continues
            for (let i = 40; i < 44; i++) {
                document.getElementById(`trad-${i}`).className = 'memory-block memory-used-r3';
                document.getElementById(`trad-${i}`).textContent = 'R3';
            }
            for (let i = 44; i < 60; i++) {
                document.getElementById(`trad-${i}`).className = 'memory-block memory-wasted';
                document.getElementById(`trad-${i}`).textContent = 'W';
            }
            
            // PagedAttention: Memory freed immediately when Request 1 completes
            let pIndex = 0;
            sequences.slice(1).forEach((seq, seqIndex) => { // Skip first sequence (completed)
                const pages = Math.ceil(seq.tokens.length / 4);
                for (let i = 0; i < pages && pIndex < 64; i++) {
                    document.getElementById(`page-${pIndex}`).className = `memory-block memory-page-r${seqIndex + 2}`;
                    document.getElementById(`page-${pIndex}`).textContent = `R${seqIndex + 2}`;
                    pIndex++;
                }
            });
            
            updateSequenceDisplay('traditional-sequences', sequences.slice(1), step);
            updateSequenceDisplay('paged-sequences', sequences.slice(1), step);
            updateStats(25, 91);
            break;
            
        case 5:
            // Final state: New requests can be added efficiently
            // Traditional: All three requests with large allocations
            sequences.forEach((seq, seqIndex) => {
                const startBlock = seqIndex * 20;
                const actualUsed = seq.tokens.length;
                
                for (let i = 0; i < 20 && startBlock + i < 64; i++) {
                    const block = document.getElementById(`trad-${startBlock + i}`);
                    if (block) {
                        if (i < actualUsed) {
                            block.className = `memory-block memory-used-r${seqIndex + 1}`;
                            block.textContent = `R${seqIndex + 1}`;
                        } else {
                            block.className = 'memory-block memory-wasted';
                            block.textContent = 'W';
                        }
                    }
                }
            });
            
            // PagedAttention: Optimal packing
            let finalPageIndex = 0;
            sequences.forEach((seq, seqIndex) => {
                const pages = Math.ceil(seq.tokens.length / 4);
                for (let i = 0; i < pages && finalPageIndex < 64; i++) {
                    document.getElementById(`page-${finalPageIndex}`).className = `memory-block memory-page-r${seqIndex + 1}`;
                    document.getElementById(`page-${finalPageIndex}`).textContent = `R${seqIndex + 1}`;
                    finalPageIndex++;
                }
            });
            
            updateSequenceDisplay('traditional-sequences', sequences, step);
            updateSequenceDisplay('paged-sequences', sequences, step);
            updateStats(35, 92);
            break;
    }
    
    currentStep = step;
}

function updateStats(tradEff, pagedEff) {
    const tradElement = document.getElementById('traditional-efficiency');
    const pagedElement = document.getElementById('paged-efficiency');
    const improvementElement = document.getElementById('improvement');
    
    if (tradElement) tradElement.textContent = tradEff + '%';
    if (pagedElement) pagedElement.textContent = pagedEff + '%';
    
    if (improvementElement && tradEff > 0) {
        const improvement = (pagedEff / tradEff).toFixed(1);
        improvementElement.textContent = improvement + 'x';
    } else if (improvementElement) {
        improvementElement.textContent = '--';
    }
}

function nextStep() {
    if (currentStep < steps.length - 1) {
        animateStep(currentStep + 1);
    }
}

function playAnimation() {
    if (animationRunning) return;
    
    animationRunning = true;
    autoPlay = true;
    console.log('Starting animation...');
    
    // Start from step 0
    let step = 0;
    animateStep(step);
    
    const playInterval = setInterval(() => {
        step++;
        console.log('Playing step:', step);
        
        if (step < steps.length && autoPlay) {
            animateStep(step);
        } else {
            console.log('Animation complete');
            clearInterval(playInterval);
            animationRunning = false;
            autoPlay = false;
        }
    }, 2500);
}

function resetAnimation() {
    console.log('Resetting animation...');
    autoPlay = false;
    animationRunning = false;
    currentStep = 0;
    
    // Reset to step 0 instead of clearing everything
    animateStep(0);
}

// Initialize on load
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded, initializing...');
    initializeMemory();
    animateStep(0);
    
    // Auto-play after a short delay
    setTimeout(() => {
        console.log('Auto-starting animation...');
        playAnimation();
    }, 2000);
});
</script>
</body>
</html>